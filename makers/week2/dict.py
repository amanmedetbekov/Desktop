# a = {} #словарь
#a = dict()

"""Методы словарарей"""


""".items()"""
#Методом items получаем из словаря ключ и значение в виде списка кортежей, то есть:
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# print(dict1.items()) #dict_items([(1, '1A'), (2, '2A'), (3, '3A'), (4, '4A')])
# list_tuple_ = dict1.items() #в переменную list_tuple_ присвоили ключ-значение в виде списка кортежей 
# print(type(list_tuple_)) #Вывод: <class 'dict_items'>




""".keys()"""
# #Методом keys() получаем только ключи
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1_keys = dict1.keys() #В перемнную dict1_keys присвоили ключи из словаря переменной dict1
# print(dict1_keys) #Вывод: dict_keys([1, 2, 3, 4])


""".values()"""
#Методом values() получаем только значение
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1_value = dict1.values() тут уже в переменную присвоили только значения
# print(dict1_value) #dict_values(['1A', '2A', '3A', '4A'])




""".get(key, None)"""
#метод get(key, None) принимает ключ и возвращает из словаря элемент с указаным key ключем, если элемента с таким ключем нет, то возвращает поумолчанию None (вместо None можно указать свое)
# например:
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# print(dict1.get(1)) #БУДЕТ 1А
# print(dict1.get(5)) # None
# print(dict1.get(5, 'Нет')) # Вернет:  Нет

""".clear()"""
# Метод copy очищает словарь, но не удаляет из памяти (остается пустой словарь)
# Например:
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1.clear()
# print(dict1) #Выдает пустой словарь: {}

""".copy()"""
#Метод copy - копирует словарь
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict2 = dict1.copy() #скопировали dict1 в dict2



""".pop(key, default)"""
# Метод pop(key, default) - (key-ключ) pop(key, default): удаляет элемент по ключу key и возвращает удаленный элемент. Если элемент с данным ключом отсутствует, то возвращается значение default (также можно вместо default свое указать)
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1.pop(2, 'Нет в словаре')  #{2: '2A'} удален из словаря 
# dict1.pop(5, 'Нет в словаре') # выводит 'Нет в словаре', потому что ключ 5 нет в словаре
# deleted_elem = dict1.pop(1) # {1: '1A'} удален из словаря в переменной dict1, но сохранили в переменной deleted_elem
# print(deleted_elem) #Вывод: 1A


""".popitem()"""
#Метод popitem()  рандомно удаляет\возвращает элемент в словаре.

# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# del_with_popitem = dict1.popitem() # сохранили в переменной del_with_popitem, последний элемент (в версии python 3.8 словари являются упорядоченными, но не имеют индекса)
#                                     #то есть {4: '4A'} в виде кортежа, но удалили из переменной dict1
# print(del_with_popitem) # Вывод: (4, '4A') #кортеж
# d = dict1.pop(1)
# print(d ) #Вывод: 1A
# print(type(del_with_popitem)) #тип кортеж




""".setdefault(key, default)"""
#Метод setdefault() Возвращает элемент из словаря, в случае его отсутвтвия добавляет указанный ключ, а в значении поумолчанию None (если вместо default указать что-то, то оно будет значением)
#например есть:
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1.setdefault(5, 45) #ключ 5 в словаре в переменной dict1 нет, поэтому туда добавится в конец словаря {5, 45}. А если есть то она НЕ перезапишется
# print(dict1)
# #а в случае с dict1.get(5, 45) не сработает
# print(dict1.setdefault(4, 5)) #тут случай, когда ключ-4 есть в словаре и его значением является '4A', то указанный 45 НЕ перезапишется!



""".update()"""
#Метод update объединяет два словаря/расширяет словарь засчет другого словаря
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict2 = {5: 'd', 6: 'lk'} # второй словарь
# dict1.update(dict2) # объединили переменные dict1 и dict2, и перезаписали в переменной dict1.А переменная dict2 неизменилась
# dict3 = {1: 'faa', 2: 'koko'} #третий словарь 
# dict1.update(dict3) #объединили переменные dict1 и dict3 и перезаписали в переменной dict1 (так как в словаре переменной dict1 есть  {1: '1A', 2: '2A'} то она перезапишется на {1: 'faa', 2: 'koko'} из пременной dict3)
# print(dict1) #Вывод: {1: 'faa', 2: 'koko', 3: '3A', 4: '4A', 5: 'd', 6: 'lk'}

# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# dict1.update({'new': "new"}) # добавили новую пару ключ-значение указав внутри update({}) 
# print(dict1)



"""dict.fromkeys(seq, value)"""  #seq - это последовательность
# #Метод/функция fromkeys() создание словаря из имеющихся списков, кортежей, строк, чисел и тд
# list1 = [1, 2, 3, 4, 5,]
# dict_ = dict.fromkeys(list1, "Makers") #элементы из списка в переменной list1 преобразовали в ключей, а значением указали строку  "Makers", а если в значении не указать, то поумолчанию None будет
# print(dict_) #{1: 'Makers', 2: 'Makers', 3: 'Makers', 4: 'Makers', 5: 'Makers'}

# d = {}
# d.fromkeys(list1, "no") #так не сработает, потому что dict не указан перед fromkeys!!!
# print(d)
# string1 = 'Makers'
# d = dict.fromkeys(string1, 'no') #тут уже из строки создаем словарь 
# print(d) #Вывод: {'M': 'no', 'a': 'no', 'k': 'no', 'e': 'no', 'r': 'no', 's': 'no'}



"""Перебор элементов словаря"""
#Для перебора элементов используется цикл for, и  методы. #items(), keys(), values(). 
# dict1 = {1: '1A', 2: '2A', 3: '3A', 4: '4A'}
# for key, value in dict1.items(): #где key - это ключ, а value - значение




#Задание
# p = {'apple': 20, 'milk': 2, 'orange': 30}
# print(p)
# while p:
#     v = input('Введите, чтобы убрать из списка: ')
#     for i in list(p.keys()):
#         if str(i) == str(v):
#             p.pop(i)
#             print(p)
# if not p is True:
#     print('Ваш список пуст, подойдите к кассе, чтобы расплатиться')
